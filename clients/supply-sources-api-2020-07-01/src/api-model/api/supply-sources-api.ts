/* tslint:disable */
/* eslint-disable */
/**
 * Selling Partner API for Supply Sources
 * Manage configurations and capabilities of seller supply sources.
 *
 * The version of the OpenAPI document: 2020-07-01
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, replaceWithSerializableTypeIfNeeded } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { CreateSupplySourceRequest } from '../models';
// @ts-ignore
import type { CreateSupplySourceResponse } from '../models';
// @ts-ignore
import type { ErrorList } from '../models';
// @ts-ignore
import type { GetSupplySourcesResponse } from '../models';
// @ts-ignore
import type { SupplySource } from '../models';
// @ts-ignore
import type { UpdateSupplySourceRequest } from '../models';
// @ts-ignore
import type { UpdateSupplySourceStatusRequest } from '../models';
/**
 * SupplySourcesApi - axios parameter creator
 */
export const SupplySourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Archive a supply source, making it inactive. Cannot be undone.
         * @param {string} supplySourceId The unique identifier of a supply source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveSupplySource: async (supplySourceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplySourceId' is not null or undefined
            assertParamExists('archiveSupplySource', 'supplySourceId', supplySourceId)
            const localVarPath = `/supplySources/2020-07-01/supplySources/{supplySourceId}`
                .replace(`{${"supplySourceId"}}`, encodeURIComponent(String(supplySourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new supply source.
         * @param {CreateSupplySourceRequest} payload A request to create a supply source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupplySource: async (payload: CreateSupplySourceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('createSupplySource', 'payload', payload)
            const localVarPath = `/supplySources/2020-07-01/supplySources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a supply source.
         * @param {string} supplySourceId The unique identifier of a supply source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupplySource: async (supplySourceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplySourceId' is not null or undefined
            assertParamExists('getSupplySource', 'supplySourceId', supplySourceId)
            const localVarPath = `/supplySources/2020-07-01/supplySources/{supplySourceId}`
                .replace(`{${"supplySourceId"}}`, encodeURIComponent(String(supplySourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The path to retrieve paginated supply sources.
         * @param {string} [nextPageToken] The pagination token to retrieve a specific page of results.
         * @param {number} [pageSize] The number of supply sources to return per paginated request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupplySources: async (nextPageToken?: string, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/supplySources/2020-07-01/supplySources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (nextPageToken !== undefined) {
                localVarQueryParameter['nextPageToken'] = nextPageToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the configuration and capabilities of a supply source.
         * @param {string} supplySourceId The unique identitier of a supply source.
         * @param {UpdateSupplySourceRequest} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupplySource: async (supplySourceId: string, payload?: UpdateSupplySourceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplySourceId' is not null or undefined
            assertParamExists('updateSupplySource', 'supplySourceId', supplySourceId)
            const localVarPath = `/supplySources/2020-07-01/supplySources/{supplySourceId}`
                .replace(`{${"supplySourceId"}}`, encodeURIComponent(String(supplySourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the status of a supply source.
         * @param {string} supplySourceId The unique identifier of a supply source.
         * @param {UpdateSupplySourceStatusRequest} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupplySourceStatus: async (supplySourceId: string, payload?: UpdateSupplySourceStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'supplySourceId' is not null or undefined
            assertParamExists('updateSupplySourceStatus', 'supplySourceId', supplySourceId)
            const localVarPath = `/supplySources/2020-07-01/supplySources/{supplySourceId}/status`
                .replace(`{${"supplySourceId"}}`, encodeURIComponent(String(supplySourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SupplySourcesApi - functional programming interface
 */
export const SupplySourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SupplySourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * Archive a supply source, making it inactive. Cannot be undone.
         * @param {string} supplySourceId The unique identifier of a supply source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveSupplySource(supplySourceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ErrorList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveSupplySource(supplySourceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SupplySourcesApi.archiveSupplySource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new supply source.
         * @param {CreateSupplySourceRequest} payload A request to create a supply source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSupplySource(payload: CreateSupplySourceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSupplySourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSupplySource(payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SupplySourcesApi.createSupplySource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a supply source.
         * @param {string} supplySourceId The unique identifier of a supply source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSupplySource(supplySourceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupplySource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSupplySource(supplySourceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SupplySourcesApi.getSupplySource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The path to retrieve paginated supply sources.
         * @param {string} [nextPageToken] The pagination token to retrieve a specific page of results.
         * @param {number} [pageSize] The number of supply sources to return per paginated request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSupplySources(nextPageToken?: string, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSupplySourcesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSupplySources(nextPageToken, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SupplySourcesApi.getSupplySources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the configuration and capabilities of a supply source.
         * @param {string} supplySourceId The unique identitier of a supply source.
         * @param {UpdateSupplySourceRequest} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSupplySource(supplySourceId: string, payload?: UpdateSupplySourceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ErrorList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSupplySource(supplySourceId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SupplySourcesApi.updateSupplySource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the status of a supply source.
         * @param {string} supplySourceId The unique identifier of a supply source.
         * @param {UpdateSupplySourceStatusRequest} [payload] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSupplySourceStatus(supplySourceId: string, payload?: UpdateSupplySourceStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ErrorList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSupplySourceStatus(supplySourceId, payload, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SupplySourcesApi.updateSupplySourceStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SupplySourcesApi - factory interface
 */
export const SupplySourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SupplySourcesApiFp(configuration)
    return {
        /**
         * Archive a supply source, making it inactive. Cannot be undone.
         * @param {SupplySourcesApiArchiveSupplySourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveSupplySource(requestParameters: SupplySourcesApiArchiveSupplySourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<ErrorList> {
            return localVarFp.archiveSupplySource(requestParameters.supplySourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new supply source.
         * @param {SupplySourcesApiCreateSupplySourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupplySource(requestParameters: SupplySourcesApiCreateSupplySourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateSupplySourceResponse> {
            return localVarFp.createSupplySource(requestParameters.payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a supply source.
         * @param {SupplySourcesApiGetSupplySourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupplySource(requestParameters: SupplySourcesApiGetSupplySourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<SupplySource> {
            return localVarFp.getSupplySource(requestParameters.supplySourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * The path to retrieve paginated supply sources.
         * @param {SupplySourcesApiGetSupplySourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupplySources(requestParameters: SupplySourcesApiGetSupplySourcesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetSupplySourcesResponse> {
            return localVarFp.getSupplySources(requestParameters.nextPageToken, requestParameters.pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the configuration and capabilities of a supply source.
         * @param {SupplySourcesApiUpdateSupplySourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupplySource(requestParameters: SupplySourcesApiUpdateSupplySourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<ErrorList> {
            return localVarFp.updateSupplySource(requestParameters.supplySourceId, requestParameters.payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the status of a supply source.
         * @param {SupplySourcesApiUpdateSupplySourceStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupplySourceStatus(requestParameters: SupplySourcesApiUpdateSupplySourceStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<ErrorList> {
            return localVarFp.updateSupplySourceStatus(requestParameters.supplySourceId, requestParameters.payload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for archiveSupplySource operation in SupplySourcesApi.
 */
export interface SupplySourcesApiArchiveSupplySourceRequest {
    /**
     * The unique identifier of a supply source.
     */
    readonly supplySourceId: string
}

/**
 * Request parameters for createSupplySource operation in SupplySourcesApi.
 */
export interface SupplySourcesApiCreateSupplySourceRequest {
    /**
     * A request to create a supply source.
     */
    readonly payload: CreateSupplySourceRequest
}

/**
 * Request parameters for getSupplySource operation in SupplySourcesApi.
 */
export interface SupplySourcesApiGetSupplySourceRequest {
    /**
     * The unique identifier of a supply source.
     */
    readonly supplySourceId: string
}

/**
 * Request parameters for getSupplySources operation in SupplySourcesApi.
 */
export interface SupplySourcesApiGetSupplySourcesRequest {
    /**
     * The pagination token to retrieve a specific page of results.
     */
    readonly nextPageToken?: string

    /**
     * The number of supply sources to return per paginated request.
     */
    readonly pageSize?: number
}

/**
 * Request parameters for updateSupplySource operation in SupplySourcesApi.
 */
export interface SupplySourcesApiUpdateSupplySourceRequest {
    /**
     * The unique identitier of a supply source.
     */
    readonly supplySourceId: string

    readonly payload?: UpdateSupplySourceRequest
}

/**
 * Request parameters for updateSupplySourceStatus operation in SupplySourcesApi.
 */
export interface SupplySourcesApiUpdateSupplySourceStatusRequest {
    /**
     * The unique identifier of a supply source.
     */
    readonly supplySourceId: string

    readonly payload?: UpdateSupplySourceStatusRequest
}

/**
 * SupplySourcesApi - object-oriented interface
 */
export class SupplySourcesApi extends BaseAPI {
    /**
     * Archive a supply source, making it inactive. Cannot be undone.
     * @param {SupplySourcesApiArchiveSupplySourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public archiveSupplySource(requestParameters: SupplySourcesApiArchiveSupplySourceRequest, options?: RawAxiosRequestConfig) {
        return SupplySourcesApiFp(this.configuration).archiveSupplySource(requestParameters.supplySourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new supply source.
     * @param {SupplySourcesApiCreateSupplySourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createSupplySource(requestParameters: SupplySourcesApiCreateSupplySourceRequest, options?: RawAxiosRequestConfig) {
        return SupplySourcesApiFp(this.configuration).createSupplySource(requestParameters.payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a supply source.
     * @param {SupplySourcesApiGetSupplySourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSupplySource(requestParameters: SupplySourcesApiGetSupplySourceRequest, options?: RawAxiosRequestConfig) {
        return SupplySourcesApiFp(this.configuration).getSupplySource(requestParameters.supplySourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The path to retrieve paginated supply sources.
     * @param {SupplySourcesApiGetSupplySourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSupplySources(requestParameters: SupplySourcesApiGetSupplySourcesRequest = {}, options?: RawAxiosRequestConfig) {
        return SupplySourcesApiFp(this.configuration).getSupplySources(requestParameters.nextPageToken, requestParameters.pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the configuration and capabilities of a supply source.
     * @param {SupplySourcesApiUpdateSupplySourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateSupplySource(requestParameters: SupplySourcesApiUpdateSupplySourceRequest, options?: RawAxiosRequestConfig) {
        return SupplySourcesApiFp(this.configuration).updateSupplySource(requestParameters.supplySourceId, requestParameters.payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the status of a supply source.
     * @param {SupplySourcesApiUpdateSupplySourceStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateSupplySourceStatus(requestParameters: SupplySourcesApiUpdateSupplySourceStatusRequest, options?: RawAxiosRequestConfig) {
        return SupplySourcesApiFp(this.configuration).updateSupplySourceStatus(requestParameters.supplySourceId, requestParameters.payload, options).then((request) => request(this.axios, this.basePath));
    }
}

